# tts-play Experiment Implementation Plan

Created: 2026-02-18
Status: VERIFIED
Approved: Yes
Iterations: 0
Worktree: No

> **Status Lifecycle:** PENDING -> COMPLETE -> VERIFIED
> **Iterations:** Tracks implement->verify cycles (incremented by verify phase)
>
> - PENDING: Initial state, awaiting implementation
> - COMPLETE: All tasks implemented
> - VERIFIED: All checks passed
>
> **Approval Gate:** Implementation CANNOT proceed until `Approved: Yes`
> **Worktree:** No - working directly on current branch

## Summary

**Goal:** Create a new experiment `tts-play` that synthesizes speech with Kokoro TTS and plays it through `AudioOut` from `deli-audio` instead of writing to a WAV file.

**Architecture:** Clone the structure of `tts-wav` but replace the `hound` WAV writer with `deli-audio::AudioOut`. The Kokoro TTS pipeline remains identical — synthesize to `Tensor<i16>`, then send samples to `AudioOut` for real-time PulseAudio playback.

**Tech Stack:** Rust, tokio, deli-infer (Kokoro TTS), deli-audio (AudioOut/PulseAudio)

## Scope

### In Scope

- New experiment directory `experiments/tts-play/` with Cargo.toml and `src/main.rs`
- Uses `deli-infer` Kokoro TTS to synthesize a sentence
- Sends resulting `i16` samples to `AudioOut` for playback
- No CLI arguments needed (no output file path)

### Out of Scope

- Changes to `deli-infer` or `deli-audio`
- Streaming/chunked synthesis (full synthesis then playback is fine)
- Device selection (use default PulseAudio output)

## Prerequisites

- Kokoro model files at `models/kokoro/kokoro-v1.0.onnx` and `models/kokoro/bf_emma.npy`
- PulseAudio running on the system
- espeak-ng data at `/usr/lib/x86_64-linux-gnu/espeak-ng-data`

## Context for Implementer

- **Patterns to follow:** Mirror `experiments/tts-wav/` structure for TTS setup. Follow `experiments/audio/src/play.rs` for AudioOut usage pattern (sleep after send to wait for playback).
- **Key files:**
  - `experiments/tts-wav/Cargo.toml` — template for dependencies
  - `experiments/tts-wav/src/main.rs` — template for TTS initialization and synthesis
  - `experiments/audio/src/play.rs` — reference for AudioOut usage: send samples then sleep for duration
  - `crates/deli-audio/src/audio_out.rs` — `AudioOut` API: `AudioOut::new(None, 24000)` then `audio_out.send(&samples).await`
- **Gotchas:**
  - `AudioOut::new()` panics if called outside a tokio runtime — this is fine since we use `#[tokio::main]`
  - Kokoro outputs at 24000 Hz sample rate — pass this to `AudioOut::new()`
  - `AudioOut::send()` takes `&[i16]` which matches `Tensor<i16>.data` directly
  - **AudioOut does NOT flush on drop.** Drop just drops the sender and task handle without waiting. You MUST sleep after send to let playback complete, as done in `experiments/audio/src/play.rs:58-59`: calculate duration from `samples.len() / SAMPLE_RATE`, add ~500ms padding, then `tokio::time::sleep()`

## Progress Tracking

- [x] Task 1: Create tts-play experiment

**Total Tasks:** 1 | **Completed:** 1 | **Remaining:** 0

## Implementation Tasks

### Task 1: Create tts-play experiment

**Objective:** Create the `experiments/tts-play/` directory with `Cargo.toml` and `src/main.rs` that synthesizes speech and plays it through `AudioOut`.

**Dependencies:** None

**Files:**

- Create: `experiments/tts-play/Cargo.toml`
- Create: `experiments/tts-play/src/main.rs`

**Key Decisions / Notes:**

- Dependencies: `deli-infer`, `deli-audio`, `deli-base`, `tokio` (with `rt`, `rt-multi-thread`, `macros`, `time` features)
- Remove CLI argument parsing (no output file needed)
- Replace WAV writing block with: create `AudioOut::new(None, SAMPLE_RATE)`, call `audio_out.send(&tensor.data).await?`, then sleep for playback duration + 500ms padding
- Keep the same `SENTENCE` constant and model paths
- Binary name: `tts_play` (matching the `tts_wav` naming convention)
- Follow the AudioOut pattern from `experiments/audio/src/play.rs:54-59`

**Definition of Done:**

- [ ] `experiments/tts-play/Cargo.toml` exists with all 4 dependencies (deli-infer, deli-audio, deli-base, tokio)
- [ ] `experiments/tts-play/src/main.rs` compiles
- [ ] `cargo build -p tts-play` succeeds with exit code 0
- [ ] Program sleeps after send to wait for full playback (not relying on Drop)
- [ ] Running `cargo run -p tts-play` synthesizes and plays "To be, or not to be, equals, minus one." through default audio output, then exits cleanly

**Verify:**

- `cargo build -p tts-play` — build succeeds
- `cargo run -p tts-play` — synthesizes speech, plays full sentence through speakers, exits with code 0

## Testing Strategy

- Build verification: `cargo build -p tts-play` must succeed
- Manual verification: run the binary, confirm audible speech output
- No unit tests needed — this is a thin integration experiment wiring existing crates

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
| ---- | ---------- | ------ | ---------- |
| PulseAudio not available | Low | High | Program will log a warning via AudioOut's reconnection loop; user must ensure PulseAudio is running |

## Open Questions

None.
